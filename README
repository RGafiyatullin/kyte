This thing is aimed to bind Erlang to Kyoto Cabinet via a nif-library.

The main aim is to move the long-playing requests to the separate thread in order not to bother BEAM scheduler. 

Usage:
	Use 'kyte' module.
	Basic operations supported: get, set, remove, clear, size, count.
	Those are done by kyte_db_srv behaving as gen_server.
	Servers (kyte_db_srv) are affiliated to the thread pools. 
	You can create multiple thread pools within one Erlang-node.
	


	-spec pool_create( PoolSize ::integer() ) -> {ok, PoolID :: integer()} | {error, any()}.
	-spec pool_destroy( PoolID :: integer() ) -> ok | {error, any()}.

	-type kyte_value_codec() :: 
		  raw   % raw binaries
		| etf   % the erlang terms are converted to ETF (with erlang:term_to_binary/1)
		| sext  % the erlang terms are converted to SEXT (with sext:encode/1)
		| rawz  % raw binaries are zipped (with zlib:zip/1)
		| etfz. % the terms are converted to ETF and zipped
	-record(kyte_db_args, {
		file :: string(),
		key_codec = etf :: kyte_value_codec(),
		val_codec = etf :: kyte_value_codec()
	}).

	-type kyte_db() :: {pid(), #kyte_db_args{}}. % WARNING! Please do not rely on this type's internals: this may (and most likely will) be changed in future.

	-spec db_open(PoolID :: integer(), DbArgs :: #kyte_db_args{} ) -> {ok, kyte_db()} | {error, any()}.
	-spec db_close(kyte_db()) -> ok | {error, any()}.

	-spec db_set(kyte_db(), term(), term()) -> ok | {error, any()}.
	-spec db_del(kyte_db(), term()) -> ok | {error, any()}.
	-spec db_get(kyte_db(), term()) -> {ok, term()} | {error, any()}.



